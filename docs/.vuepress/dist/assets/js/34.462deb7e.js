(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{404:function(a,t,v){"use strict";v.r(t);var _=v(10),s=Object(_.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h2",{attrs:{id:"js"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#js"}},[a._v("#")]),a._v(" js")]),a._v(" "),v("h3",{attrs:{id:"标准内置对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#标准内置对象"}},[a._v("#")]),a._v(" 标准内置对象")]),a._v(" "),v("h4",{attrs:{id:"值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#值"}},[a._v("#")]),a._v(" 值")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("Infinity，无穷大")])]),a._v(" "),v("li",[v("p",[a._v("NaN，不是一个数字")])]),a._v(" "),v("li",[v("p",[a._v("undefined，未赋值")])]),a._v(" "),v("li",[v("p",[a._v("globalThis，任何环境下的 this")])])]),a._v(" "),v("h4",{attrs:{id:"函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[a._v("#")]),a._v(" 函数")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("parseInt,从给定的字符串中解析出的一个整数或者 NaN")])]),a._v(" "),v("li",[v("p",[a._v("encodeURI,url 编码，以下情况不会被编码，解码(decodeURI())")]),a._v(" "),v("ol",[v("li",[v("p",[a._v("保留字符：; , / ? : @ & = + $")])]),a._v(" "),v("li",[v("p",[a._v("非转义的字符：字母 数字 - _ . ! ~ * ' ( )")])]),a._v(" "),v("li",[v("p",[a._v("数字符号：#")])])])]),a._v(" "),v("li",[v("p",[a._v("encodeURIComponent，url 编码，除了非转义字符,解码(decodeURIComponent())")]),a._v(" "),v("ol",[v("li",[a._v("字母 数字 - _ . ! ~ * ' ( )")])])]),a._v(" "),v("li",[v("p",[a._v("isFinite(),判断是否是有限数值")])])]),a._v(" "),v("h4",{attrs:{id:"数字、日期对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数字、日期对象"}},[a._v("#")]),a._v(" 数字、日期对象")]),a._v(" "),v("ul",[v("li",[a._v("BigInt：可以表示大于 2^53 - 1 的整数")])]),a._v(" "),v("h3",{attrs:{id:"数据类型区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据类型区别"}},[a._v("#")]),a._v(" 数据类型区别")]),a._v(" "),v("ul",[v("li",[v("p",[v("strong",[a._v("值类型")])]),a._v(" "),v("p",[a._v("占用空间固定，保存在栈中（当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。）")])]),a._v(" "),v("li",[v("p",[v("strong",[a._v("引用类型")])]),a._v(" "),v("p",[a._v("占用空间不固定，保存在堆中（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。）")]),a._v(" "),v("div",{staticStyle:{"text-align":"center"}},[v("img",{attrs:{src:"https://xjq-blog.oss-cn-shenzhen.aliyuncs.com/blog/typeOfData/reference-type.png"}})])])]),a._v(" "),v("h3",{attrs:{id:"继承"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[a._v("#")]),a._v(" 继承")]),a._v(" "),v("h3",{attrs:{id:"原型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[a._v("#")]),a._v(" 原型")]),a._v(" "),v("p",[a._v("每一个 js 对象(除 null)都有另一个对象有关联,这里另一个对象就是原型,每个对象都从原型继承属属性")]),a._v(" "),v("h3",{attrs:{id:"观察者模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式"}},[a._v("#")]),a._v(" 观察者模式")]),a._v(" "),v("h3",{attrs:{id:"发布-订阅模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#发布-订阅模式"}},[a._v("#")]),a._v(" 发布-订阅模式")]),a._v(" "),v("h3",{attrs:{id:"模块化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模块化"}},[a._v("#")]),a._v(" 模块化")]),a._v(" "),v("h2",{attrs:{id:"es6"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[a._v("#")]),a._v(" ES6")]),a._v(" "),v("h3",{attrs:{id:"数据结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[a._v("#")]),a._v(" 数据结构")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("Set")]),a._v(" "),v("p",[a._v("类数组，成员唯一,可遍历")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("add")])]),a._v(" "),v("li",[v("p",[a._v("delete")])]),a._v(" "),v("li",[v("p",[a._v("has")])]),a._v(" "),v("li",[v("p",[a._v("clear")])]),a._v(" "),v("li",[v("p",[a._v("keys")])]),a._v(" "),v("li",[v("p",[a._v("values")])]),a._v(" "),v("li",[v("p",[a._v("forEach")])])])]),a._v(" "),v("li",[v("p",[a._v("WeakSet")]),a._v(" "),v("p",[a._v("只能存储对象，不可遍历，垃圾回收运行前后，部分成员可能被回收")])]),a._v(" "),v("li",[v("p",[a._v("Map")]),a._v(" "),v("p",[a._v("键值对")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("size，成员总数")])]),a._v(" "),v("li",[v("p",[a._v("set，设置键名对应的键值")])]),a._v(" "),v("li",[v("p",[a._v("get，读取 key 对应的键值")])]),a._v(" "),v("li",[v("p",[a._v("has，判断是否包含某个 key")])]),a._v(" "),v("li",[v("p",[a._v("delete，删除某个键，如果删除失败，返回 false")])]),a._v(" "),v("li",[v("p",[a._v("clear")])]),a._v(" "),v("li",[v("p",[a._v("keys")])]),a._v(" "),v("li",[v("p",[a._v("values")])]),a._v(" "),v("li",[v("p",[a._v("entries")])]),a._v(" "),v("li",[v("p",[a._v("forEach")])])])]),a._v(" "),v("li",[v("p",[a._v("WeakMap")]),a._v(" "),v("p",[a._v("只支持对象作为键名")])])]),a._v(" "),v("h3",{attrs:{id:"promise"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[a._v("#")]),a._v(" Promise")]),a._v(" "),v("h3",{attrs:{id:"async-await"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#async-await"}},[a._v("#")]),a._v(" Async/Await")]),a._v(" "),v("h2",{attrs:{id:"浏览器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器"}},[a._v("#")]),a._v(" 浏览器")]),a._v(" "),v("h3",{attrs:{id:"重绘、重排"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重绘、重排"}},[a._v("#")]),a._v(" 重绘、重排")]),a._v(" "),v("h3",{attrs:{id:"浏览器渲染机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染机制"}},[a._v("#")]),a._v(" 浏览器渲染机制")]),a._v(" "),v("h2",{attrs:{id:"http-协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-协议"}},[a._v("#")]),a._v(" http 协议")]),a._v(" "),v("h3",{attrs:{id:"三次握手-四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三次握手-四次挥手"}},[a._v("#")]),a._v(" 三次握手，四次挥手")]),a._v(" "),v("h2",{attrs:{id:"状态管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#状态管理"}},[a._v("#")]),a._v(" 状态管理")]),a._v(" "),v("h3",{attrs:{id:"redux"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redux"}},[a._v("#")]),a._v(" redux")]),a._v(" "),v("h2",{attrs:{id:"框架"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#框架"}},[a._v("#")]),a._v(" 框架")]),a._v(" "),v("h3",{attrs:{id:"react"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[a._v("#")]),a._v(" react")]),a._v(" "),v("h4",{attrs:{id:"react-dev-tool"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#react-dev-tool"}},[a._v("#")]),a._v(" react dev tool")]),a._v(" "),v("h4",{attrs:{id:"portal"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#portal"}},[a._v("#")]),a._v(" portal")]),a._v(" "),v("p",[a._v("Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案")]),a._v(" "),v("h4",{attrs:{id:"生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[a._v("#")]),a._v(" 生命周期")]),a._v(" "),v("ul",[v("li",[a._v("16.4 以后")])]),a._v(" "),v("ol",[v("li",[v("p",[a._v("constructor")]),a._v(" "),v("p",[a._v("初始化 state")])]),a._v(" "),v("li",[v("p",[a._v("getDerivedStateFromProps")]),a._v(" "),v("p",[a._v("第一次渲染和更新时会调用，静态函数，无法获取 this，根据 props 更新 state，不过会导致 state 来源不单一")])]),a._v(" "),v("li",[v("p",[a._v("getSnapshotBeforeUpdate")]),a._v(" "),v("p",[a._v("在 dom 渲染前的快照，可以保存原来的 state，props")])]),a._v(" "),v("li",[v("p",[a._v("componentDidMount")]),a._v(" "),v("p",[a._v("渲染真实 dom 树后调用")])]),a._v(" "),v("li",[v("p",[a._v("componentDidUpdate")]),a._v(" "),v("p",[a._v("更新完成函数")])]),a._v(" "),v("li",[v("p",[a._v("componentWillUnmount")]),a._v(" "),v("p",[a._v("组件卸载，清除定时器")])])]),a._v(" "),v("h2",{attrs:{id:"其他"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[a._v("#")]),a._v(" 其他")]),a._v(" "),v("h3",{attrs:{id:"技术选型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#技术选型"}},[a._v("#")]),a._v(" 技术选型")]),a._v(" "),v("h4",{attrs:{id:"扩展性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#扩展性"}},[a._v("#")]),a._v(" 扩展性")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("易于增加新功能")])]),a._v(" "),v("li",[v("p",[a._v("新功能的增加带来的系统复杂度")])])]),a._v(" "),v("h4",{attrs:{id:"维护性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#维护性"}},[a._v("#")]),a._v(" 维护性")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("代码逻辑清晰、简洁，便于扩展与修改")])]),a._v(" "),v("li",[v("p",[a._v("高内聚、低耦合")])]),a._v(" "),v("li",[v("p",[a._v("文档健全")])])]),a._v(" "),v("h4",{attrs:{id:"易于测试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#易于测试"}},[a._v("#")]),a._v(" 易于测试")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("功能分层清晰")])]),a._v(" "),v("li",[v("p",[a._v("副作用少，尽量使用纯函数")])]),a._v(" "),v("li",[v("p",[a._v("开发工具完善度、社区活跃度、生态圈")])])]),a._v(" "),v("h4",{attrs:{id:"易于构建"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#易于构建"}},[a._v("#")]),a._v(" 易于构建")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("使用通用技术与架构")])]),a._v(" "),v("li",[v("p",[a._v("构建工具的选择")])])]),a._v(" "),v("h2",{attrs:{id:"操作系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#操作系统"}},[a._v("#")]),a._v(" 操作系统")]),a._v(" "),v("h3",{attrs:{id:"进程与线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程"}},[a._v("#")]),a._v(" 进程与线程")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("进程：资源分配的基本单位，程序执行时的一个实例")])]),a._v(" "),v("li",[v("p",[a._v("线程：程序执行的最小单位")])]),a._v(" "),v("li",[v("p",[a._v("区别")]),a._v(" "),v("ol",[v("li",[v("p",[a._v("进程是资源分配的最小单位，线程是程序执行的最小单位")])]),a._v(" "),v("li",[v("p",[a._v("进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此 CPU 切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多")])]),a._v(" "),v("li",[v("p",[a._v("线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点")])]),a._v(" "),v("li",[v("p",[a._v("但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间")])])])])]),a._v(" "),v("h2",{attrs:{id:"数据结构与算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据结构与算法"}},[a._v("#")]),a._v(" 数据结构与算法")]),a._v(" "),v("h2",{attrs:{id:"web-安全"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#web-安全"}},[a._v("#")]),a._v(" web 安全")]),a._v(" "),v("h3",{attrs:{id:"xss-跨站脚本攻击"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#xss-跨站脚本攻击"}},[a._v("#")]),a._v(" XSS(跨站脚本攻击)")]),a._v(" "),v("p",[a._v("浏览器渲染整个 HTML 文档的过程中出现了不被预期的脚本指令执行")]),a._v(" "),v("h4",{attrs:{id:"存储型-xss"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#存储型-xss"}},[a._v("#")]),a._v(" 存储型 XSS")]),a._v(" "),v("p",[a._v("前端提交的数据未经处理存储到数据库,在读取返回到页面上时引发问题,比如执行 js 代码")]),a._v(" "),v("h4",{attrs:{id:"反射型-xss"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#反射型-xss"}},[a._v("#")]),a._v(" 反射型 XSS")]),a._v(" "),v("p",[a._v("发出请求时，XSS 代码作为输入提交到服务端，服务端解析后返回这段 XSS 代码，最后浏览器解析执行")]),a._v(" "),v("h4",{attrs:{id:"dom-型-xss"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dom-型-xss"}},[a._v("#")]),a._v(" DOM 型 XSS")]),a._v(" "),v("h4",{attrs:{id:"防范"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#防范"}},[a._v("#")]),a._v(" 防范")]),a._v(" "),v("ol",[v("li",[v("p",[a._v("转译特殊字符")])]),a._v(" "),v("li",[v("p",[a._v("cookie，设置 Secure 只允许 https 协议传输，设置 HttpOnly，防止 js 脚本获取 cookie")])]),a._v(" "),v("li",[v("p",[a._v("CSP 内容安全策略")])])]),a._v(" "),v("h3",{attrs:{id:"csrf-跨站请求伪造"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#csrf-跨站请求伪造"}},[a._v("#")]),a._v(" CSRF(跨站请求伪造)")]),a._v(" "),v("p",[a._v("一种诱骗受害者提交恶意请求的攻击，攻击者盗用了你的身份，以你的名义发送恶意请求，请求到达后端时，服务器将无法区分恶意请求和合法请求。CSRF 能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账等。")]),a._v(" "),v("h4",{attrs:{id:"防范-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#防范-2"}},[a._v("#")]),a._v(" 防范")]),a._v(" "),v("ol",[v("li",[v("p",[a._v("同源检测，禁止外域的请求")])]),a._v(" "),v("li",[v("p",[a._v("CSRF token，服务端校验 token")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);