(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{235:function(t,e,a){"use strict";a.r(e);var o=a(0),_=Object(o.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[a("a",{attrs:{href:"https://www.jianshu.com/p/412c874c5add",target:"_blank",rel:"noopener noreferrer"}},[t._v("useEffect 和 useLayoutEffect 的区别"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"常用-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用-api"}},[t._v("#")]),t._v(" 常用 API")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("调用 setState 之后发生了什么？")]),t._v(" "),a("p",[t._v("在代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。")])]),t._v(" "),a("li",[a("p",[t._v("shouldComponentUpdate 的作用是啥以及为何它这么重要？")]),t._v(" "),a("p",[t._v("shouldComponentUpdate 允许我们手动地判断是否要进行组件更新，根据组件的应用场景设置函数的合理返回值能够帮我们避免不必要的更新。")])]),t._v(" "),a("li",[a("p",[t._v("严格模式的作用")]),t._v(" "),a("ol",[a("li",[t._v("识别不安全的生命周期")]),t._v(" "),a("li",[t._v("关于使用过时字符串 ref API 的警告")]),t._v(" "),a("li",[t._v("关于使用废弃的 findDOMNode 方法的警告")]),t._v(" "),a("li",[t._v("检测意外的副作用")]),t._v(" "),a("li",[t._v("检测过时的 context API")])])]),t._v(" "),a("li",[a("p",[t._v("react 构造函数的作用(constuctor)的作用")]),t._v(" "),a("ol",[a("li",[t._v("初始化 this.state")]),t._v(" "),a("li",[t._v("函数方法绑定到实例")]),t._v(" "),a("li",[t._v("新建父类 this 对象,子类必须调用 super()方法获取 this 对象")]),t._v(" "),a("li",[t._v("无状态组件无需构造函数,内部无需维护 state")])])]),t._v(" "),a("li",[a("p",[t._v("hooks 使用原则")]),t._v(" "),a("p",[t._v("只能在顶层调用 hook,这样可以确保每次组件渲染时都已相同的顺序调用 Hook,不能在循环、条件或者嵌套函数中调用 hook")])]),t._v(" "),a("li",[a("p",[t._v("useEffect 和 useLayoutEffect 区别")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("useEffect\n这个钩子是异步的,但是 class 的 componentDidMount 和 componentDidUpdate 是同步的,在 render 结束后就运行,useEffect 在大部分场景下都比 class 的方式性能更好.")])]),t._v(" "),a("li",[a("p",[t._v("useLayoutEffect")]),t._v(" "),a("p",[t._v("这个是用在处理 DOM 的时候,当你的 useEffect 里面的操作需要处理 DOM,并且会改变页面的样式,就需要用这个,否则可能会出现出现闪屏问题, useLayoutEffect 里面的 callback 函数会在 DOM 更新完成后立即执行,但是会在浏览器进行任何绘制之前运行完成,阻塞了浏览器的绘制.")])])])])]),t._v(" "),a("blockquote",[a("p",[a("a",{attrs:{href:"https://www.jianshu.com/p/e984206553c2",target:"_blank",rel:"noopener noreferrer"}},[t._v("Redux 实现原理解析及应用"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux"}},[t._v("#")]),t._v(" redux")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("为什么要用 redux\n在 React 中，数据在组件中是单向流动的，数据从一个方向父组件流向子组件（通过 props）,所以，两个非父子组件之间通信就相对麻烦，redux 的出现就是为了解决 state 里面的数据问题")])]),t._v(" "),a("li",[a("p",[t._v("三大原则")]),t._v(" "),a("ol",[a("li",[t._v("单一数据源:整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。")]),t._v(" "),a("li",[t._v("State 是只读的:唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。")]),t._v(" "),a("li",[t._v("使用纯函数来执行修改:为了描述 action 如何改变 state tree ，你需要编写 reducers。")])])])])])}),[],!1,null,null,null);e.default=_.exports}}]);