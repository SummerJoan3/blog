(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{234:function(t,e,v){"use strict";v.r(e);var _=v(0),a=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("blockquote",[v("p",[v("a",{attrs:{href:"https://www.imooc.com/article/details/id/30554",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端面试必备技巧——HTTP 协议类"),v("OutboundLink")],1)])]),t._v(" "),v("h2",{attrs:{id:"http-协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-协议"}},[t._v("#")]),t._v(" http 协议")]),t._v(" "),v("h3",{attrs:{id:"特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),v("ol",[v("li",[t._v("简单快速")])]),t._v(" "),v("p",[t._v("每个资源 URI(统一资源符)是固定的,比如图片、页面地址,所以 HTTP 协议中处理比较简单,访问某个资源输入 URI 即可")]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("灵活")])]),t._v(" "),v("p",[t._v("每个 http 协议中。有一个头部分,有个数据类型,通过一个 http 协议的就可以完成不同数据类型的传输")]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("无连接")])]),t._v(" "),v("p",[t._v("连接一次就会断开,不会保持连接")]),t._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[t._v("无状态")])]),t._v(" "),v("p",[t._v("客户端和服务端两种身份,客户端向服务端请求一个图片,http 帮你建立连接、传输结束后,连接断开,下次客户端在请求数据,服务端是无法区分上次连接和这次连接是否是同一身份,因为服务端没有记住你的状态,单从 http 协议上是无法区分两次连接者的身份,大多数网站都需要登录才能获取更多操作,登录后携带你的信息请求时,服务器才能辨认你的身份")]),t._v(" "),v("h3",{attrs:{id:"http-报文"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-报文"}},[t._v("#")]),t._v(" HTTP 报文")]),t._v(" "),v("p",[t._v("HTTP 报文组成:")]),t._v(" "),v("ol",[v("li",[t._v("报文首部:服务端或者客户端需要处理的请求或者响应的内容及属性")]),t._v(" "),v("li",[t._v("空行")]),t._v(" "),v("li",[t._v("报文主体:数据")])]),t._v(" "),v("h3",{attrs:{id:"请求报文"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#请求报文"}},[t._v("#")]),t._v(" 请求报文")]),t._v(" "),v("p",[t._v("请求报文由请求首部(请求行+请求头)、空行、请求主体组成,每部分都由空行作为结束标志")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("请求行:请求方法+空格+统一资源标识符(URL+空格+HTTP 版本+CRLF")])]),t._v(" "),v("li",[v("p",[t._v("请求头:字段名+冒号+值+CRLF,也就是键值对组成")])]),t._v(" "),v("li",[v("p",[t._v("空行:告诉服务端请求头已经结束")])]),t._v(" "),v("li",[v("p",[t._v("请求体:GET 没有请求数据,POST 有")])])]),t._v(" "),v("h3",{attrs:{id:"响应报文"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#响应报文"}},[t._v("#")]),t._v(" 响应报文")]),t._v(" "),v("p",[t._v("状态行、响应头、空行、响应体")]),t._v(" "),v("ol",[v("li",[t._v("状态行:HTTP 版本+空格+状态码+空格状态码描述+CRLF")]),t._v(" "),v("li",[t._v("响应头:字段名+冒号+值+CRLF")]),t._v(" "),v("li",[t._v("空行")]),t._v(" "),v("li",[t._v("响应体")])]),t._v(" "),v("h3",{attrs:{id:"首部详解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#首部详解"}},[t._v("#")]),t._v(" 首部详解")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("通用首部:请求报文、响应报文都拥有")]),t._v(" "),v("p",[t._v("Cache-Control 控制缓存的行为\nConnection 逐跳首部、连接的管理\nDate 创建报文的日期时间\nTransfer-Encoding 指定报文主体的传输编码方式\nUpgrade 升级为其他协议")])]),t._v(" "),v("li",[v("p",[t._v("请求首部")]),t._v(" "),v("p",[t._v("Accept 用户代理可处理的媒体类型\nAccept-Charset 优先的字符集\nAccept-Encoding 优先的内容编码\nAccept-Language 优先的语言（自然语言）\nAuthorization Web 认证信息\nExpect 期待服务器的特定行为\nFrom 用户的电子邮箱地址\nHost 请求资源所在服务器\nIf-Match 比较实体标记（ETag）\nIf-Modified-Since 比较资源的更新时间\nIf-None-Match 比较实体标记（与 If-Match 相反）\nIf-Range 资源未更新时发送实体 Byte 的范围请求\nIf-Unmodified-Since 比较资源的更新时间（与 If-Modified-Since 相反）\nMax-Forwards 最大传输逐跳数\nProxy-Authorization 代理服务器要求客户端的认证信息\nRange 实体的字节范围请求\nReferer 对请求中 URI 的原始获取方\nTE 传输编码的优先级\nUser-Agent HTTP 客户端程序的信息")])]),t._v(" "),v("li",[v("p",[t._v("响应首部")]),t._v(" "),v("p",[t._v("Accept-Ranges 是否接受字节范围请求\nAge 推算资源创建经过时间\nETag 资源的匹配信息\nLocation 令客户端重定向至指定 URI\nProxy-Authenticate 代理服务器对客户端的认证信息\nRetry-After 对再次发起请求的时机要求\nServer HTTP 服务器的安装信息\nVary 代理服务器缓存的管理信息\nWWW-Authenticate 服务器对客户端的认证信息")])]),t._v(" "),v("li",[v("p",[t._v("实体首部:补充了资源内容更新时间等与实体有关的信息")]),t._v(" "),v("p",[t._v("Allow 资源可支持的 HTTP 方法\nContent-Encoding 实体主体适用的编码方式\nContent-Language 实体主体的自然语言\nContent-Length 实体主体的大小（单位：字节）\nContent-Location 替代对应资源的 URI\nContent-MD5 实体主体的报文摘要\nContent-Range 实体主体的位置范围\nContent-Type 实体主体的媒体类型\nExpires 实体主体过期的日期时间\nLast-Modified 资源的最后修改日期时间")])])]),t._v(" "),v("h2",{attrs:{id:"浏览器中输入-url-之后"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器中输入-url-之后"}},[t._v("#")]),t._v(" 浏览器中输入 URL 之后?")]),t._v(" "),v("ol",[v("li",[v("p",[v("strong",[t._v("首先通过 DNS 服务器解析了服务器 ip:")])]),t._v(" "),v("ol",[v("li",[v("p",[t._v("查询浏览器缓存(浏览器会缓存之前拿到的 DNS 2-30 分钟时间)")])]),t._v(" "),v("li",[v("p",[t._v("检查系统缓存,检查 hosts 文件是否有这个网址映射关系,如果有就调用这个 IP 地址映射,完成域名解析")])]),t._v(" "),v("li",[v("p",[t._v("检查路由器缓存")])]),t._v(" "),v("li",[v("p",[t._v("查询 ISP DNS 缓存：ISP 服务商 DNS 缓存（本地服务器缓存）")])])])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("与服务器进行 TCP 的三次握手、四次挥手")])])])]),t._v(" "),v("p",[t._v("第一次：浏览器向服务器发送请求（SYN=1）,等待服务器确认；")]),t._v(" "),v("p",[t._v("第二次：服务器收到请求并确认,回复一个指令（SYN=1,ACK=1）；")]),t._v(" "),v("p",[t._v("第三次：客户端收到服务器的回复指令,并返回确认（ACK=1）；")]),t._v(" "),v("p",[t._v("1.首先浏览器发送连接请求报文,2.服务器接受连接后回复 ACK 报文,并为这次连接分配资源。3.浏览器接收到 ACK 报文后也向服务器发生 ACK 报文,并分配资源,这样 TCP 连接就建立了,开始数据传输。浏览器向服务器发送 http 的请求报文,浏览器从服务器读取响应报文,传输完成后,进行 TCP 的四次挥手,浏览器关闭连接。")]),t._v(" "),v("p",[t._v("服务器返回 html 文档之后,浏览器的渲染引擎开始 dom 解析过程（构建 DOM 树->渲染树（Render tree）->布局 render 树->绘制 render 树）")]),t._v(" "),v("blockquote",[v("p",[v("a",{attrs:{href:"http://xieyufei.com/2018/08/06/Http-Cache.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端也要懂 Http 缓存机制"),v("OutboundLink")],1)])]),t._v(" "),v("blockquote",[v("p",[v("a",{attrs:{href:"https://segmentfault.com/a/1190000016199807",target:"_blank",rel:"noopener noreferrer"}},[t._v("10 分钟彻底搞懂 Http 的强制缓存和协商缓存"),v("OutboundLink")],1)])]),t._v(" "),v("h2",{attrs:{id:"http-缓存机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存机制"}},[t._v("#")]),t._v(" Http 缓存机制")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("Http 缓存的分类: Http 缓存可以分为两大类,强制缓存（也称强缓存）和协商缓存。两类缓存规则不同,强制缓存在缓存数据未失效的情况下,不需要再和服务器发生交互；而协商缓存,顾名思义,需要进行比较判断是否可以使用缓存。两类缓存规则可以同时存在,强制缓存优先级高于协商缓存,也就是说,当执行强制缓存的规则时,如果缓存生效,直接使用缓存,不再执行协商缓存规则。")])])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("强缓存:强制缓存只有首次请求才会跟服务器通信,读取缓存资源时不会发出任何请求,资源的 Status 状态码为 200,资源的 Size 为 from memory 或者 from disk ,http 1.1 版本的实现优先级会高于 http 1.0 版本的实现。")])]),t._v(" "),v("ol",[v("li",[v("p",[t._v("Expires(http 1.0):Expires 的值是服务器告诉浏览器的缓存过期时间（值为 GMT 时间,即格林尼治时间）,即下一次请求时,如果浏览器端的当前时间还没有到达过期时间,则直接使用缓存数据。")])]),t._v(" "),v("li",[v("p",[t._v("Cache-Control(http 1.1):设置相对时间,隔多久过期,Cache-Control 拥有多个值:")]),t._v(" "),v("ol",[v("li",[t._v("private：客户端可以缓存")]),t._v(" "),v("li",[t._v("public：客户端和代理服务器均可缓存；")]),t._v(" "),v("li",[t._v("max-age=xxx：缓存的资源将在 xxx 秒后过期；")]),t._v(" "),v("li",[t._v("no-cache：需要使用协商缓存来验证是否过期；")]),t._v(" "),v("li",[t._v("no-store：不可缓存")])])])]),t._v(" "),v("p",[t._v("最常用的字段就是 max-age=xxx ,表示缓存的资源将在 xxx 秒后过期。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("协商缓存:协商缓存与强制缓存的不同之处在于,协商缓存每次读取数据时都需要跟服务器通信,并且会增加缓存标识。在第一次请求服务器时,服务器会返回资源,并且返回一个资源的缓存标识,一起存到浏览器的缓存数据库。当第二次请求资源时,浏览器会首先将缓存标识发送给服务器,服务器拿到标识后判断标识是否匹配,如果不匹配,表示资源有更新,服务器会将新数据和新的缓存标识一起返回到浏览器；如果缓存标识匹配,表示资源没有更新,并且返回 304 状态码,浏览器就读取本地缓存服务器中的数据。")])]),t._v(" "),v("ol",[v("li",[v("p",[t._v("在 http 1.0 版本中,第一次请求资源时服务器通过 Last-Modified 来设置响应头的缓存标识,并且把资源最后修改的时间作为值填入,然后将资源返回给浏览器。在第二次请求时,浏览器会首先带上 If-Modified-Since 请求头去访问服务器,服务器会将 If-Modified-Since 中携带的时间与资源修改的时间匹配,如果时间不一致,服务器会返回新的资源,并且将 Last-Modified 值更新,作为响应头返回给浏览器。如果时间一致,表示资源没有更新,服务器返回 304 状态码,浏览器拿到响应状态码后从本地缓存数据库中读取缓存资源。")])]),t._v(" "),v("li",[v("p",[t._v("在 http 1.1 版本中,服务器通过 Etag 来设置响应头缓存标识。Etag 的值由服务端生成。在第一次请求时,服务器会将资源和 Etag 一并返回给浏览器,浏览器将两者缓存到本地缓存数据库。在第二次请求时,浏览器会将 Etag 信息放到 If-None-Match 请求头去访问服务器,服务器收到请求后,会将服务器中的文件标识与浏览器发来的标识进行对比,如果不相同,服务器返回更新的资源和新的 Etag ,如果相同,服务器返回 304 状态码,浏览器读取缓存。")])])])])]),t._v(" "),v("p",[t._v("协商缓存每次请求都会与服务器交互,第一次是拿数据和标识的过程,第二次开始,就是浏览器询问服务器资源是否有更新的过程。每次请求都会传输数据,如果命中缓存,则资源的 Status 状态码为 304 而不是 200 。同样的,一般来讲为了兼容,两个版本的协商缓存都会被实现,http 1.1 版本的实现优先级会高于 http 1.0 版本的实现。")]),t._v(" "),v("h2",{attrs:{id:"安全"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#安全"}},[t._v("#")]),t._v(" 安全")]),t._v(" "),v("h3",{attrs:{id:"xss-攻击"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#xss-攻击"}},[t._v("#")]),t._v(" XSS 攻击")]),t._v(" "),v("p",[t._v("跨站脚本 (Cross-Site Scripting, XSS) 是一种代码注入方式, 为了与 CSS 区分所以被称作 XSS. 早期常见于网络论坛, 起因是网站没有对用户的输入进行严格的限制, 使得攻击者可以将脚本上传到帖子让其他人浏览到有恶意脚本的页面, 其注入方式很简单包括但不限于 JavaScript / VBScript / CSS / Flash 等.")]),t._v(" "),v("p",[t._v("最常见的表现为恶意痴汉通过网站的表单输入框输入代码,植入到提供给其它用户使用的页面中。比如这些代码包括 HTML 代码和客户端脚本。攻击者利用 XSS 漏洞旁路掉访问控制——例如同源策略(same origin policy)。")]),t._v(" "),v("p",[t._v("解决办法:最简单的办法防治办法,还是将前端输出数据都进行转义最为稳妥,虽然显示出来是有 script 标签的,但是实际上,script 标签的左右尖括号(><),均被转义为 html 字符实体,所以,便不会被当做标签来解析的,但是实际显示的时候,这两个尖括号,还是可以正常展示的。")]),t._v(" "),v("h3",{attrs:{id:"csrf"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#csrf"}},[t._v("#")]),t._v(" CSRF")]),t._v(" "),v("p",[t._v("CSRF(Cross-site request forgery 跨站请求伪造,也被称为“One Click Attack”或者 Session Riding,通常缩写为 CSRF 或者 XSRF,是一种对网站的恶意利用。攻击者盗用了你的身份,以你的名义发送恶意请求,对服务器来说这个请求是完全合法的")]),t._v(" "),v("p",[t._v("CSRF 攻击攻击原理及过程如下:")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("用户 C 打开浏览器,访问受信任网站 A,输入用户名和密码请求登录网站 A；")])]),t._v(" "),v("li",[v("p",[t._v("在用户信息通过验证后,网站 A 产生 Cookie 信息并返回给浏览器,此时用户登录网站 A 成功,可以正常发送请求到网站 A；")])]),t._v(" "),v("li",[v("p",[t._v("用户未退出网站 A 之前,在同一浏览器中,打开一个 TAB 页访问网站 B；")])]),t._v(" "),v("li",[v("p",[t._v("网站 B 接收到用户请求后,返回一些攻击性代码,并发出一个请求要求访问第三方站点 A；")])]),t._v(" "),v("li",[v("p",[t._v("浏览器在接收到这些攻击性代码后,根据网站 B 的请求,在用户不知情的情况下携带 Cookie 信息,向网站 A 发出请求。网站 A 并不知道该请求其实是由 B 发起的,所以会根据用户 C 的 Cookie 信息以 C 的权限处理该请求,导致来自网站 B 的恶意代码被执行。")])])]),t._v(" "),v("p",[t._v("防御 CSRF 攻击：目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。")])])}),[],!1,null,null,null);e.default=a.exports}}]);